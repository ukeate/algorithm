package base.direct;

/**
 * 博弈论问题：吃草游戏
 * 
 * 游戏规则：
 * - 两个人轮流吃草，每次只能吃1, 4, 16, 64, ...（4的幂次）份草
 * - 最后一个吃草的人获胜
 * - 给定初始草的数量，判断先手是否能获胜
 * 
 * 解题思路：
 * 1. 暴力递归找出规律
 * 2. 发现规律：当n%5==0或n%5==2时后手胜，否则先手胜
 */
// 只能吃1,4,16, 谁最后吃谁赢
public class EatGrass {
    /**
     * 递归解法：判断在给定草数量下先手是否能赢
     * 
     * 思路：对于当前玩家，尝试所有可能的吃草数量（1, 4, 16, ...）
     * 如果存在一种吃法使得对手处于必败状态，则当前玩家必胜
     * 
     * @param n 剩余草的数量
     * @return "先手" 如果先手必胜，"后手" 如果后手必胜
     */
    public static String win1(int n) {
        // 基础情况
        if (n < 5) {
            // n=0: 无草可吃，当前玩家败（后手胜）
            // n=1: 可以吃1，对手面对0败（先手胜）
            // n=2: 只能吃1，对手面对1胜（后手胜）
            // n=3: 可以吃1，对手面对2败（先手胜）
            // n=4: 可以吃1或4，对手面对3或0都败（先手胜）
            return (n == 0 || n == 2) ? "后手" : "先手";
        }
        
        int base = 1; // 当前尝试的吃草数量（4的幂次）
        while (base <= n) {
            // 如果吃掉base份草后，对手处于必败状态，则当前玩家必胜
            if (win1(n - base).equals("后手")) {
                return "先手";
            }
            // 防止溢出：如果base > n/4，则下一次base*4会超出范围
            if (base > n / 4) {
                break;
            }
            base *= 4; // 下一个4的幂次
        }
        // 所有选择都无法让对手败，则当前玩家必败
        return "后手";
    }

    /**
     * 规律解法：通过找规律得出的O(1)解法
     * 
     * 规律：当n%5==0或n%5==2时，先手必败（后手胜）
     *      否则先手必胜
     * 
     * 这个规律可以通过打表找出：
     * n=0: 后手  (0%5=0)
     * n=1: 先手  (1%5=1)
     * n=2: 后手  (2%5=2)
     * n=3: 先手  (3%5=3)
     * n=4: 先手  (4%5=4)
     * n=5: 后手  (5%5=0)
     * ...
     * 
     * @param n 草的数量
     * @return "先手" 如果先手必胜，"后手" 如果后手必胜
     */
    public static String win2(int n) {
        if (n % 5 == 0 || n % 5 == 2) {
            return "后手";
        } else {
            return "先手";
        }
    }

    /**
     * 测试方法：验证规律的正确性并观察结果模式
     */
    public static void main(String[] args) {
        // 打印前50个结果，观察规律
        for (int i = 0; i <= 50; i++) {
            System.out.println(i + ":" + win1(i));
        }
    }
}
