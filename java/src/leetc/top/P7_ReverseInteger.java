package leetc.top;

/**
 * LeetCode 7. 整数反转 (Reverse Integer)
 * 
 * 问题描述：
 * 给你一个 32 位的有符号整数 x，返回将 x 中的数字部分反转后的结果。
 * 如果反转后整数超过 32 位的有符号整数的范围 [−2³¹, 2³¹ − 1]，就返回 0。
 * 
 * 示例：
 * - 输入：x = 123，输出：321
 * - 输入：x = -123，输出：-321
 * - 输入：x = 1534236469，输出：0（反转后溢出）
 * 
 * 解法思路：
 * 防溢出的数字反转：
 * 1. 判断正负性，统一转为负数处理（避免正数溢出问题）
 * 2. 逐位提取数字，构建反转结果
 * 3. 在每次构建前检查是否会溢出
 * 4. 使用 Integer.MIN_VALUE 作为溢出边界检查基准
 * 
 * 为什么转负数：
 * - Integer.MIN_VALUE = -2^31，其绝对值比 Integer.MAX_VALUE = 2^31-1 大1
 * - 统一处理避免了正数可能的溢出问题
 * 
 * 溢出判断：
 * - 当 ans < MIN_VALUE/10 时，下次乘10必定溢出
 * - 当 ans == MIN_VALUE/10 且待添加数字过大时，也会溢出
 * 
 * 时间复杂度：O(log x) - 取决于x的位数
 * 空间复杂度：O(1) - 只使用常数额外空间
 */
public class P7_ReverseInteger {
    
    /**
     * 反转32位有符号整数
     * 
     * 算法步骤：
     * 1. 提取符号位，将所有数转为负数处理
     * 2. 逐位提取原数字的个位数
     * 3. 在构建反转数字前检查溢出
     * 4. 根据原符号返回正确结果
     * 
     * @param x 输入的32位有符号整数
     * @return 反转后的整数，溢出时返回0
     */
    public static int reverse(int x) {
        // 判断符号：true表示原数为负数
        boolean neg = ((x >>> 31) & 1) == 1;
        
        // 统一转为负数处理，避免正数溢出问题
        x = neg ? x : -x;
        
        // 溢出检查的边界值
        int m = Integer.MIN_VALUE / 10;    // -214748364
        int o = Integer.MIN_VALUE % 10;    // -8
        
        int ans = 0;  // 构建反转后的结果
        
        // 逐位反转
        while (x != 0) {
            // 溢出检查：如果下次乘10会超出范围，返回0
            if (ans < m || (ans == m && x % 10 < o)) {
                return 0;
            }
            
            // 构建反转数字：ans = ans * 10 + 当前位
            ans = ans * 10 + x % 10;
            x /= 10;  // 移除已处理的个位数
        }
        
        // 根据原数的符号返回结果
        return neg ? ans : Math.abs(ans);
    }
}
