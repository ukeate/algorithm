package leetc.top;

/**
 * LeetCode 335. 路径交叉 (Self Crossing)
 * 
 * 问题描述：
 * 给定一个含有 n 个正数的数组 distance。你从点 (0, 0) 开始，先向北移动 distance[0] 米，
 * 然后向西移动 distance[1] 米，向南移动 distance[2] 米，向东移动 distance[3] 米，
 * 持续这个过程......换句话说，每次移动后你的方向会逆时针变化。
 * 
 * 判断你所经过的路径是否相交。路径相交是指存在任意两条边相互交叉。
 * 
 * 示例：
 * 输入：distance = [2,1,1,2]
 * 输出：true
 * 解释：路径相交了
 * 
 * 输入：distance = [1,2,3,4]
 * 输出：false
 * 解释：路径没有相交
 * 
 * 解法思路：
 * 几何分析 + 分类讨论：
 * 
 * 1. 移动模式分析：
 *    - 北(↑) → 西(←) → 南(↓) → 东(→) → 北(↑) ...
 *    - 每4步为一个周期，形成逆时针螺旋
 * 
 * 2. 交叉情况分类：
 *    路径交叉只可能发生在有限的几种情况下：
 *    
 *    情况1：第四条线与第一条线交叉
 *    - 条件：i >= 3 且满足特定的几何关系
 *    
 *    情况2：第五条线与第一条线交叉  
 *    - 条件：i >= 4 且满足特定的几何关系
 *    
 *    情况3：第六条线与第一条线交叉
 *    - 条件：i >= 5 且满足特定的几何关系
 * 
 * 3. 几何条件分析：
 *    对于每条线段，检查它是否与之前的线段相交：
 *    - 使用坐标几何和线段相交的数学条件
 *    - 考虑边界情况和特殊位置
 * 
 * 4. 优化观察：
 *    由于路径的特殊性（逆时针螺旋），只需要检查：
 *    - 当前线段与前面有限几条线段的交叉情况
 *    - 不需要检查所有可能的线段对
 * 
 * 核心思想：
 * - 几何建模：将移动转化为坐标系中的线段
 * - 模式识别：螺旋路径的交叉只发生在特定模式下
 * - 局部检查：只需检查相邻的几条线段，不需要全局检查
 * 
 * 关键技巧：
 * - 分类讨论：穷举所有可能的交叉模式
 * - 几何判断：使用线段相交的数学条件
 * - 边界处理：考虑端点重合等特殊情况
 * 
 * 时间复杂度：O(n) - 每条线段检查常数次
 * 空间复杂度：O(1) - 只需要常数个变量
 * 
 * LeetCode链接：https://leetcode.com/problems/self-crossing/
 */
public class P335_SelfCrossing {
    
    /**
     * 判断路径是否自相交
     * 
     * 算法流程：
     * 1. 从第4条线段开始检查（前3条线段不可能相交）
     * 2. 对每条线段，检查它与前面线段的交叉情况
     * 3. 根据几何关系判断是否发生交叉
     * 4. 一旦发现交叉，立即返回true
     * 
     * @param distance 移动距离数组
     * @return 路径是否自相交
     */
    public boolean isSelfCrossing(int[] distance) {
        if (distance == null || distance.length < 4) {
            return false; // 少于4条线段不可能相交
        }
        
        int n = distance.length;
        
        // 从第4条线段开始检查交叉情况
        for (int i = 3; i < n; i++) {
            // 情况1：第i条线与第i-3条线相交
            // 形成一个"十字"交叉模式
            if (isCrossing1(distance, i)) {
                return true;
            }
            
            // 情况2：第i条线与第i-4条线相交（需要至少5条线段）
            if (i >= 4 && isCrossing2(distance, i)) {
                return true;
            }
            
            // 情况3：第i条线与第i-5条线相交（需要至少6条线段）
            if (i >= 5 && isCrossing3(distance, i)) {
                return true;
            }
        }
        
        return false; // 没有发现交叉
    }
    
    /**
     * 检查情况1：第i条线与第i-3条线是否相交
     * 
     * 几何条件：
     * - 第i条线段与第i-3条线段形成"回折"
     * - 当前方向的线段足够长，回到之前的位置
     * 
     * @param d 距离数组
     * @param i 当前线段索引
     * @return 是否相交
     */
    private boolean isCrossing1(int[] d, int i) {
        // 检查第i条线是否与第i-3条线相交
        // 条件：d[i-1] <= d[i-3] && d[i] >= d[i-2]
        return d[i - 1] <= d[i - 3] && d[i] >= d[i - 2];
    }
    
    /**
     * 检查情况2：第i条线与第i-4条线是否相交
     * 
     * 几何条件：
     * - 需要考虑更复杂的几何关系
     * - 涉及5条线段的相对位置
     * 
     * @param d 距离数组
     * @param i 当前线段索引
     * @return 是否相交
     */
    private boolean isCrossing2(int[] d, int i) {
        // 第i条线与第i-4条线相交的条件
        // 需要满足特定的几何约束
        return d[i - 2] == d[i - 4] && 
               d[i - 3] <= d[i - 1] && 
               d[i - 1] + d[i - 5] >= d[i - 3] && 
               d[i] + d[i - 4] >= d[i - 2];
    }
    
    /**
     * 检查情况3：第i条线与第i-5条线是否相交
     * 
     * 几何条件：
     * - 最复杂的交叉情况
     * - 涉及6条线段的几何关系
     * 
     * @param d 距离数组
     * @param i 当前线段索引
     * @return 是否相交
     */
    private boolean isCrossing3(int[] d, int i) {
        // 第i条线与第i-5条线相交的条件
        // 需要满足多个几何约束的组合
        return d[i - 3] <= d[i - 1] && 
               d[i - 1] <= d[i - 3] + d[i - 5] && 
               d[i - 2] <= d[i - 4] && 
               d[i - 4] <= d[i - 2] + d[i] && 
               d[i - 5] + d[i - 1] >= d[i - 3] && 
               d[i - 4] + d[i] >= d[i - 2];
    }
}
