package leetc.top;

/**
 * LeetCode 283. 移动零 (Move Zeroes)
 * 
 * 问题描述：
 * 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
 * 
 * 请注意：
 * - 必须在原数组上操作，不能拷贝额外的数组。
 * - 尽量减少操作次数。
 * 
 * 示例：
 * 输入: nums = [0,1,0,3,12]
 * 输出: [1,3,12,0,0]
 * 
 * 输入: nums = [0]
 * 输出: [0]
 * 
 * 解法思路：
 * 双指针 + 交换法：
 * 1. 使用快慢双指针，慢指针to指向下一个非零元素应该放置的位置
 * 2. 快指针i遍历数组，遇到非零元素时与to位置交换
 * 3. 每次交换后，to向前移动一位
 * 4. 这样可以保证所有非零元素按原有顺序排在数组前面，零元素自然被"挤"到后面
 * 
 * 核心思想：
 * - 维护数组的两个区域：前面的非零区域和后面的待处理区域
 * - 通过交换操作逐步扩大非零区域
 * - 保持非零元素的相对顺序不变
 * 
 * 算法优势：
 * - 原地操作，空间复杂度O(1)
 * - 一次遍历，时间复杂度O(n)
 * - 操作次数最少，每个非零元素最多交换一次
 * - 自动处理边界情况（全零、全非零、单元素等）
 * 
 * 时间复杂度：O(n) - 需要遍历数组一次
 * 空间复杂度：O(1) - 只使用常数额外空间
 * 
 * LeetCode链接：https://leetcode.com/problems/move-zeroes/
 */
public class P283_MoveZeroes {
    
    /**
     * 交换数组中两个位置的元素
     * 
     * @param arr 数组
     * @param i 第一个位置
     * @param j 第二个位置
     */
    private static void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }

    /**
     * 移动零到数组末尾，保持非零元素相对顺序
     * 
     * 算法步骤：
     * 1. 初始化慢指针to=0，指向下一个非零元素的目标位置
     * 2. 使用快指针i遍历整个数组
     * 3. 当nums[i]不为0时：
     *    - 将nums[i]与nums[to]交换
     *    - to指针向前移动一位
     * 4. 遍历结束后，所有非零元素都在数组前面，零元素在后面
     * 
     * 工作原理：
     * - to指针始终指向"非零区域"的边界
     * - 每找到一个非零元素，就将其交换到非零区域的末尾
     * - 交换操作确保了相对顺序的保持
     * 
     * 示例过程：
     * 原数组: [0, 1, 0, 3, 12]
     * i=0,to=0: nums[0]=0，跳过
     * i=1,to=0: nums[1]=1，交换 -> [1, 0, 0, 3, 12], to=1
     * i=2,to=1: nums[2]=0，跳过
     * i=3,to=1: nums[3]=3，交换 -> [1, 3, 0, 0, 12], to=2
     * i=4,to=2: nums[4]=12，交换 -> [1, 3, 12, 0, 0], to=3
     * 
     * @param nums 包含零和非零元素的数组，原地修改
     */
    public static void moveZeroes(int[] nums) {
        int to = 0;  // 慢指针：指向下一个非零元素应该放置的位置
        
        // 快指针遍历数组
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] != 0) {
                // 发现非零元素，交换到非零区域的末尾
                swap(nums, to++, i);
            }
            // 如果是零元素，直接跳过，让快指针继续前进
        }
    }
}
