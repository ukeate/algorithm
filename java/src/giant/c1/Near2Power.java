package giant.c1;

/**
 * 找到大于等于给定数字的最小2的幂次方
 * 
 * 问题描述：
 * 给定一个整数n，找到大于等于n的最小的2的幂次方。
 * 例如：n=5，返回8（因2^3）；n=8，返回8（因2^3）。
 * 
 * 算法思路：
 * 这是一个经典的位运算优化问题。核心思想是利用位运算将最高位之后的所有位都置为1，
 * 然后加1得到下一个2的幂次方。
 * 
 * 算法步骤：
 * 1. 首先n--，这样如果n本身就是2的幂次方，结果仍然是n
 * 2. 通过一系列右移和按位或操作，将n的最高位之后的所有位都置为1
 * 3. 最终n+1就是所求的结果
 * 
 * 位运算原理：
 * n |= n >>> 1  // 将最高位及其右移1位的结果进行按位或
 * n |= n >>> 2  // 使得最高位往右的2位内都为1
 * n |= n >>> 4  // 使得最高位往右的4位内都为1
 * 依此类推直到整个32位整数的最高位之后都为1
 * 
 * 时间复杂度：O(1)
 * 空间复杂度：O(1)
 */
public class Near2Power {
    /**
     * 使用位运算找到大于等于n的最小2的幂次方
     * 
     * 算法详解：
     * 1. n--: 处理n本身就是2的幂次方的情况
     * 2. 通过一系列右移和按位或操作，使得n的最高位及其之后的所有位都为1
     * 3. 最终n+1就是下一个2的幂次方
     * 
     * 例如n=5 (101)：
     * n-- 后 n=4 (100)
     * n |= n >>> 1: 100 | 010 = 110
     * n |= n >>> 2: 110 | 001 = 111
     * n+1 = 8 (1000)
     * 
     * @param n 输入整数
     * @return 大于等于n的最小2的幂次方
     */
    public static int find(int n) {
        n--; // 先减1，处理n本身就是2的幂次方的特殊情况
        
        // 通过一系列右移和按位或操作，将最高位之后的所有位都置为1
        n |= n >>> 1;  // 处理最高位及其右移1位
        n |= n >>> 2;  // 处理最高位及其右移2位
        n |= n >>> 4;  // 处理最高位及其右移4位
        n |= n >>> 8;  // 处理最高位及其右移8位
        n |= n >>> 16; // 处理最高位及其右移16位（覆盖整个32位整数）
        
        // 处理负数的特殊情况，返回1（因2^0）
        return (n < 0) ? 1 : n + 1;
    }

    /**
     * 测试方法：演示算法的使用和一些边界情况
     */
    public static void main(String[] args) {
        System.out.println(find(-120)); // 测试负数情况
        System.out.println(-9 >>> 1);   // 演示无符号右移对负数的影响
    }
}
