package leetc.top;

/**
 * LeetCode 45. 跳跃游戏 II (Jump Game II)
 * 
 * 问题描述：
 * 给你一个非负整数数组 nums，你最初位于数组的第一个位置。
 * 数组中的每个元素代表你在该位置可以跳跃的最大长度。
 * 你的目标是使用最少的跳跃次数到达数组的最后一个位置。
 * 假设你总是可以到达数组的最后一个位置。
 * 
 * 示例：
 * - 输入：nums = [2,3,1,1,4]，输出：2
 * - 解释：跳到最后一个位置的最小跳跃数是2，路径为：1→3→5（下标0→2→4）
 * 
 * 解法思路：
 * 贪心算法 - 跳跃范围扩展：
 * 1. 维护当前跳跃能到达的边界cur和下一跳能到达的最远位置next
 * 2. 遍历数组，当到达当前跳跃边界时，必须进行一次跳跃
 * 3. 每次跳跃都选择能到达最远位置的策略（贪心）
 * 4. 实时更新下一跳的最远可达位置
 * 
 * 核心思想：
 * - 将问题分层：第1跳能到达的范围、第2跳能到达的范围...
 * - 在每一层中贪心地选择能到达最远位置的点作为下一跳的起点
 * 
 * 时间复杂度：O(n) - 每个位置最多访问一次
 * 空间复杂度：O(1) - 只使用常数额外空间
 */
public class P45_JumpGameII {
    
    /**
     * 计算到达数组最后位置的最少跳跃次数
     * 
     * 算法步骤：
     * 1. 初始化跳跃次数jump=0，当前边界cur=0，下一跳最远位置next=0
     * 2. 遍历数组（不包括最后一个位置，因为到达即可）：
     *    - 如果当前位置超出了当前跳跃边界，需要进行一次跳跃
     *    - 更新下一跳能到达的最远位置
     * 3. 返回总跳跃次数
     * 
     * @param arr 表示跳跃长度的非负整数数组
     * @return 到达最后位置的最少跳跃次数
     */
    public static int jump(int[] arr) {
        // 边界情况：空数组或只有一个元素
        if (arr == null || arr.length == 0) {
            return 0;
        }
        
        int jump = 0;   // 跳跃次数
        int cur = 0;    // 当前跳跃能到达的右边界
        int next = 0;   // 下一跳能到达的最远位置
        
        // 遍历数组，注意不需要处理最后一个位置
        for (int i = 0; i < arr.length; i++) {
            // 如果当前位置超出了当前跳跃的边界
            if (cur < i) {
                jump++;     // 必须进行一次跳跃
                cur = next; // 更新当前跳跃的右边界为下一跳的最远位置
            }
            
            // 更新下一跳能到达的最远位置
            next = Math.max(next, i + arr[i]);
        }
        
        return jump;
    }
}
