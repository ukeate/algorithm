package giant.c1;

/**
 * 最少交换次数使字符串左右分区问题
 * 
 * 问题描述：
 * 给定一个只包含'G'和'B'字符的字符串，可以交换任意两个位置的字符。
 * 目标是使得整个字符串分成左右两部分，一部分全部是一种字符。
 * 有两种方案：1)左部全G右部全B  2)左部全B右部全G
 * 求实现这个目标的最少交换次数。
 * 
 * 算法思路：
 * 这是一个经典的“最少交换次数”问题。关键在于理解：
 * 对于方案1（左G右B）：所有G字符都应该在左侧的连续位置上，
 * 即位置0, 1, 2, ..., G的个数-1。对于每个不在正确位置的G，
 * 需要计算它移动到正确位置的距离。
 * 
 * 数学原理：
 * 如果字符串中有k个G，那么它们的最优位置应该是0,1,2,...,k-1。
 * 对于第i个遇到的G（在位置pos），它应该移动到位置i，
 * 所以交换次数是abs(pos - i)。由于我们按顺序遍历，
 * 且正确位置总是递增的，所以实际上是pos - i。
 * 
 * 时间复杂度：O(n)
 * 空间复杂度：O(n)（用于字符数组）
 */
public class MinSwap {
    /**
     * 计算最少交换次数使得字符串左右分区
     * 
     * 算法详解：
     * 1. 方案1：让所有G在左侧，所有B在右侧
     *    - 遍历字符串，对于第i个遇到的G（在位置pos），它应该在位置i
     *    - 交换次数累加pos - i（因为pos >= i）
     * 
     * 2. 方案2：让所有B在左侧，所有G在右侧
     *    - 同理，对于第i个遇到的B，计算它移动到位置i的成本
     * 
     * 最终返回两种方案中的最小值。
     * 
     * @param s 输入字符串，只包含'G'和'B'
     * @return 最少交换次数
     */
    public static int min(String s) {
        if (s == null || s.equals("")) {
            return 0;
        }
        
        char[] str = s.toCharArray();
        int steps1 = 0; // 方案1：左G右B的交换次数
        int gi = 0;     // 已经遇到的G的个数（也是下一个G应该放的位置）
        int steps2 = 0; // 方案2：左B右G的交换次数
        int bi = 0;     // 已经遇到的B的个数（也是下一个B应该放的位置）
        
        // 遍历字符串，同时计算两种方案的成本
        for (int i = 0; i < str.length; i++) {
            if (str[i] == 'G') {
                // 当前位置i的G应该在位置gi，所以需要交换i - gi次
                steps1 += i - (gi++);
            } else { // str[i] == 'B'
                // 当前位置i的B应该在位置bi，所以需要交换i - bi次
                steps2 += i - (bi++);
            }
        }
        
        // 返回两种方案中的最小值
        return Math.min(steps1, steps2);
    }

}
