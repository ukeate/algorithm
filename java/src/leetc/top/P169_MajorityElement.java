package leetc.top;

/**
 * LeetCode 169. 多数元素 (Majority Element)
 * 
 * 问题描述：
 * 给定一个大小为 n 的数组 nums ，返回其中的多数元素。
 * 多数元素是指在数组中出现次数大于 ⌊n/2⌋ 的元素。
 * 你可以假设数组是非空的，并且给定的数组总是存在多数元素。
 * 
 * 进阶：尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。
 * 
 * 解法思路：
 * 摩尔投票算法（Boyer-Moore Voting Algorithm）：
 * 1. 核心思想：多数元素的个数大于n/2，其他所有元素个数之和小于n/2
 * 2. 可以将多数元素看作+1，其他元素看作-1，最终和一定是正数
 * 3. 维护一个候选者和计数器
 * 4. 遇到相同元素计数+1，遇到不同元素计数-1
 * 5. 计数为0时更换候选者
 * 
 * 算法正确性：
 * - 多数元素个数 > n/2，其他元素个数 < n/2
 * - 即使在最坏情况下，多数元素也不会被完全抵消
 * - 最终留下的候选者一定是多数元素
 * 
 * 关键洞察：
 * - 多数元素的"多数"特性保证了算法的正确性
 * - 每次抵消操作最多消除一个多数元素和一个非多数元素
 * - 由于多数元素数量占优，最终一定会胜出
 * 
 * 算法流程：
 * 1. 初始化候选者cand和血量hp
 * 2. 血量为0时，当前元素成为新候选者
 * 3. 当前元素等于候选者时，血量+1
 * 4. 当前元素不等于候选者时，血量-1
 * 5. 最终候选者就是多数元素
 * 
 * 时间复杂度：O(n) - 一次遍历数组
 * 空间复杂度：O(1) - 只使用常数额外空间
 * 
 * LeetCode链接：https://leetcode.com/problems/majority-element/
 */
public class P169_MajorityElement {
    
    /**
     * 使用摩尔投票算法找到多数元素
     * 
     * @param nums 整数数组
     * @return 多数元素
     */
    public static int majorityElement(int[] nums) {
        int cand = 0;  // 候选者
        int hp = 0;    // 血量（计数器）
        
        for (int i = 0; i < nums.length; i++) {
            if (hp == 0) {
                // 血量为0，当前元素成为新候选者
                cand = nums[i];
                hp = 1;
            } else if (nums[i] == cand) {
                // 遇到相同元素，血量+1
                hp++;
            } else {
                // 遇到不同元素，血量-1（抵消）
                hp--;
            }
        }
        
        // 由于题目保证多数元素存在，最终候选者就是答案
        return cand;
    }
}
