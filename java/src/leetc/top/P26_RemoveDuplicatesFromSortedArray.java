package leetc.top;

/**
 * LeetCode 26. 删除有序数组中的重复项 (Remove Duplicates from Sorted Array)
 * 
 * 问题描述：
 * 给你一个有序数组 nums，请你原地删除重复出现的元素，使每个元素只出现一次，返回删除后数组的新长度。
 * 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。
 * 
 * 元素的相对顺序应该保持一致。
 * 
 * 示例：
 * 输入：nums = [1,1,2]
 * 输出：2, nums = [1,2,_]
 * 解释：函数应该返回新的长度2，并且原数组nums的前两个元素被修改为1, 2。不需要考虑数组中超出新长度后面的元素。
 * 
 * 输入：nums = [0,0,1,1,1,2,2,3,3,4]
 * 输出：5, nums = [0,1,2,3,4,_,_,_,_,_]
 * 
 * 解法思路：
 * 双指针法：
 * 1. 慢指针done指向不重复区域的最后一个位置
 * 2. 快指针i遍历整个数组
 * 3. 当发现新元素时，将其放入不重复区域的下一个位置
 * 4. 由于数组已排序，相同元素必然相邻，只需比较相邻元素即可
 * 
 * 核心思想：
 * - 维护数组的两个区域：[0, done]为不重复区域，[done+1, i-1]为重复元素
 * - 不重复区域始终保持有序且无重复
 * - 当发现新元素时，扩展不重复区域
 * 
 * 时间复杂度：O(n) - 需要遍历数组一次
 * 空间复杂度：O(1) - 只使用常数额外空间
 * 
 * LeetCode链接：https://leetcode.com/problems/remove-duplicates-from-sorted-array/
 */
public class P26_RemoveDuplicatesFromSortedArray {
    
    /**
     * 删除有序数组中的重复项
     * 
     * 算法步骤：
     * 1. 处理边界情况：空数组或长度小于2的数组
     * 2. 初始化慢指针done=0，指向不重复区域的最后一个位置
     * 3. 用快指针i从第二个元素开始遍历
     * 4. 当nums[i] != nums[done]时，说明发现新元素：
     *    - 将done向前移动一位（扩展不重复区域）
     *    - 将新元素放入新位置：nums[++done] = nums[i]
     * 5. 返回不重复元素的个数：done + 1
     * 
     * 工作原理：
     * - done始终指向不重复区域的最后一个元素
     * - 每次发现新元素时，done先移动，然后放入新元素
     * - 这样保证[0, done]区域内的元素都不重复且有序
     * 
     * 示例过程（nums = [0,0,1,1,1,2,2,3,3,4]）：
     * 初始：done=0, nums[0]=0
     * i=1: nums[1]=0, 0==0, 跳过
     * i=2: nums[2]=1, 1!=0, nums[++done=1]=1 → [0,1,1,1,1,2,2,3,3,4]
     * i=3: nums[3]=1, 1==1, 跳过
     * i=4: nums[4]=1, 1==1, 跳过
     * i=5: nums[5]=2, 2!=1, nums[++done=2]=2 → [0,1,2,1,1,2,2,3,3,4]
     * ... 最终：[0,1,2,3,4,_,_,_,_,_], done=4, 返回5
     * 
     * @param nums 有序整数数组，原地修改
     * @return 删除重复项后的数组长度
     */
    public static int removeDuplicates(int[] nums) {
        // 边界情况：空数组
        if (nums == null) {
            return 0;
        }
        
        // 边界情况：长度小于2的数组，无重复项
        if (nums.length < 2) {
            return nums.length;
        }
        
        int done = 0;  // 慢指针：指向不重复区域的最后一个位置
        
        // 快指针从第二个元素开始遍历
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] != nums[done]) {
                // 发现新元素，扩展不重复区域
                nums[++done] = nums[i];
            }
            // 如果nums[i] == nums[done]，说明是重复元素，直接跳过
        }
        
        // 返回不重复元素的个数（索引+1）
        return done + 1;
    }
}
