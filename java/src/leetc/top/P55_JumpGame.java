package leetc.top;

/**
 * LeetCode 55. 跳跃游戏 (Jump Game)
 * 
 * 问题描述：
 * 给定一个非负整数数组 nums，你最初位于数组的第一个下标。
 * 数组中的每个元素代表你在该位置可以跳跃的最大长度。
 * 判断你是否能够到达最后一个下标。
 * 
 * 示例：
 * - 输入：nums = [2,3,1,1,4]，输出：true
 * - 解释：可以先跳1步，从下标0到达下标1，然后跳3步到达最后一个下标
 * - 输入：nums = [3,2,1,0,4]，输出：false
 * - 解释：无论怎样，总会到达下标为3的位置，但该位置的最大跳跃长度是0，无法继续
 * 
 * 解法思路：
 * 贪心算法 - 维护最远可达位置：
 * 1. 维护一个变量max表示当前能到达的最远位置
 * 2. 遍历数组，对于每个位置i：
 *    - 如果i > max，说明无法到达位置i，返回false
 *    - 否则，更新最远可达位置：max = max(max, i + nums[i])
 * 3. 如果能遍历完整个数组，说明可以到达最后位置
 * 
 * 核心思想：
 * - 贪心地维护能到达的最远位置
 * - 如果某个位置超出了最远可达范围，就无法到达终点
 * 
 * 时间复杂度：O(n) - 只需要遍历一次数组
 * 空间复杂度：O(1) - 只使用常数额外空间
 */
public class P55_JumpGame {
    
    /**
     * 判断是否能够到达数组的最后一个位置
     * 
     * 算法步骤：
     * 1. 处理边界情况：数组长度小于2时直接返回true
     * 2. 初始化最远可达位置为nums[0]
     * 3. 从位置1开始遍历：
     *    - 如果当前位置超出最远可达范围，返回false
     *    - 否则更新最远可达位置
     * 4. 遍历完成说明可以到达终点
     * 
     * @param nums 表示跳跃长度的非负整数数组
     * @return 是否能够到达最后一个下标
     */
    public boolean canJump(int[] nums) {
        // 边界情况：数组长度小于2，不需要跳跃或只有一个元素
        if (nums == null || nums.length < 2) {
            return true;
        }
        
        int max = nums[0];  // 当前能到达的最远位置
        
        // 从位置1开始遍历（位置0已经在max初始化中处理）
        for (int i = 1; i < nums.length; i++) {
            // 如果当前位置超出了最远可达范围，无法到达
            if (i > max) {
                return false;
            }
            
            // 更新最远可达位置：当前位置i + 从i能跳跃的最大距离nums[i]
            max = Math.max(max, i + nums[i]);
        }
        
        // 能够遍历完整个数组，说明可以到达最后位置
        return true;
    }
}
