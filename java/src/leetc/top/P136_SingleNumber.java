package leetc.top;

/**
 * LeetCode 136. 只出现一次的数字 (Single Number)
 * 
 * 问题描述：
 * 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。
 * 找出那个只出现了一次的元素。
 * 
 * 说明：
 * 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？
 * 
 * 解法思路：
 * 异或运算的性质：
 * 1. 任何数和 0 做异或运算，结果仍然是原来的数：a ⊕ 0 = a
 * 2. 任何数和其自身做异或运算，结果是 0：a ⊕ a = 0
 * 3. 异或运算满足交换律和结合律：a ⊕ b ⊕ a = (a ⊕ a) ⊕ b = 0 ⊕ b = b
 * 
 * 算法实现：
 * 遍历数组，将所有元素进行异或运算。由于相同的数字异或结果为0，
 * 最终结果就是只出现一次的那个数字。
 * 
 * 示例分析：
 * 数组 [2,2,1] 的异或过程：
 * 2 ⊕ 2 ⊕ 1 = (2 ⊕ 2) ⊕ 1 = 0 ⊕ 1 = 1
 * 
 * 核心思想：
 * - 利用异或运算的自反性消除成对出现的数字
 * - 最终剩下的就是只出现一次的数字
 * - 不需要额外存储空间，满足题目要求
 * 
 * 时间复杂度：O(n) - 遍历一次数组
 * 空间复杂度：O(1) - 只使用一个变量
 * 
 * LeetCode链接：https://leetcode.com/problems/single-number/
 */
public class P136_SingleNumber {
    
    /**
     * 找出只出现一次的数字
     * 
     * @param nums 整数数组，除一个元素外其余元素都出现两次
     * @return 只出现一次的数字
     */
    public static int singleNumber(int[] nums) {
        int eor = 0;  // 异或累积器，初始化为0
        
        // 遍历数组，累积异或所有元素
        for (int num : nums) {
            eor ^= num;  // 异或运算
        }
        
        // 由于相同数字异或为0，最终结果就是单独的数字
        return eor;
    }
}
