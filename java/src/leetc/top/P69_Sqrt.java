package leetc.top;

/**
 * LeetCode 69. x 的平方根 (Sqrt(x))
 * 
 * 问题描述：
 * 给你一个非负整数 x，计算并返回 x 的算术平方根。
 * 由于返回类型是整数，结果只保留整数部分，小数部分将被舍去。
 * 
 * 注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5。
 * 
 * 示例：
 * - 输入：x = 4，输出：2
 * - 输入：x = 8，输出：2（说明：8 的算术平方根是 2.82842...，舍去小数部分后是2）
 * 
 * 解法思路：
 * 二分查找 - 在[1, x]范围内查找最大的整数，使得其平方不超过x：
 * 1. 确定搜索范围：[1, x]
 * 2. 对于中点m，检查m²与x的关系
 * 3. 如果m² ≤ x，说明答案可能是m或更大，在右半部分搜索
 * 4. 如果m² > x，说明答案在左半部分，搜索范围缩小到[l, m-1]
 * 5. 返回最后一个满足m² ≤ x的m值
 * 
 * 为什么是最后一个满足条件的值：
 * 我们要找的是floor(√x)，即不超过√x的最大整数
 * 
 * 时间复杂度：O(log x) - 二分查找
 * 空间复杂度：O(1) - 只使用常数额外空间
 */
public class P69_Sqrt {
    
    /**
     * 计算x的算术平方根（只保留整数部分）
     * 
     * @param x 非负整数
     * @return x的算术平方根的整数部分
     */
    public static int mySqrt(int x) {
        // 特殊情况处理
        if (x == 0) {
            return 0;  // √0 = 0
        }
        if (x < 3) {
            return 1;  // √1 = 1, √2 = 1（舍去小数部分）
        }
        
        // 二分查找变量
        long ans = 1;     // 保存满足条件的最大值
        long l = 1;       // 搜索范围左边界
        long r = x;       // 搜索范围右边界
        long m = 0;       // 中点
        
        // 二分查找：寻找最大的m使得m² ≤ x
        while (l <= r) {
            m = (l + r) / 2;    // 计算中点，避免溢出
            
            if (m * m <= x) {
                // 当前m满足条件，记录答案并尝试找更大的值
                ans = m;
                l = m + 1;      // 在右半部分继续搜索
            } else {
                // 当前m过大，在左半部分搜索
                r = m - 1;
            }
        }
        
        return (int) ans;  // 返回最大的满足m² ≤ x的整数m
    }
}
