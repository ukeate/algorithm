package leetc.top;

/**
 * LeetCode 36. 有效的数独 (Valid Sudoku)
 * 
 * 问题描述：
 * 请你判断一个 9×9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。
 * 
 * 数独有效性规则：
 * 1. 数字 1-9 在每一行只能出现一次
 * 2. 数字 1-9 在每一列只能出现一次  
 * 3. 数字 1-9 在每一个以粗实线分隔的 3×3 宫内只能出现一次
 * 
 * 注意：
 * - 一个有效的数独（部分已被填充）不一定是可解的
 * - 只需要根据以上规则，验证已经填入的数字是否有效即可
 * - 给定数独序列只包含数字 1-9 和字符 '.'
 * - '.' 代表空格
 * 
 * 解法思路：
 * 布尔数组记录法：
 * 1. 使用三个二维布尔数组分别记录行、列、3×3子网格中数字的使用情况
 * 2. 遍历整个数独盘，对每个非空格子检查是否违反规则
 * 3. 如果数字已在当前行、列或子网格中出现，则数独无效
 * 4. 否则标记该数字在对应行、列、子网格中已使用
 * 
 * 核心技巧：
 * - 子网格编号计算：bid = 3 * (i / 3) + (j / 3)
 * - 将9×9网格划分为9个3×3子网格，编号0-8
 * - 一次遍历同时检查三个约束条件
 * 
 * 时间复杂度：O(1) - 固定遍历9×9=81个格子
 * 空间复杂度：O(1) - 使用固定大小的布尔数组
 * 
 * LeetCode链接：https://leetcode.com/problems/valid-sudoku/
 */
public class P36_ValidSudoku {
    
    /**
     * 验证数独是否有效
     * 
     * 算法步骤：
     * 1. 初始化三个布尔数组：row（行）、col（列）、bucket（3×3子网格）
     * 2. 遍历9×9的数独盘
     * 3. 对每个非空格子：
     *    - 计算所属的3×3子网格编号
     *    - 检查该数字是否已在当前行、列、子网格中出现
     *    - 如果已出现，返回false（无效）
     *    - 否则标记该数字在对应位置已使用
     * 4. 遍历完成，返回true（有效）
     * 
     * 数据结构设计：
     * - row[i][num]：第i行是否已使用数字num
     * - col[j][num]：第j列是否已使用数字num
     * - bucket[bid][num]：第bid个3×3子网格是否已使用数字num
     * 
     * 子网格编号计算：
     * - 9×9网格被划分为9个3×3子网格
     * - 子网格按行优先顺序编号：0-8
     * - 位置(i,j)的子网格编号：3 * (i / 3) + (j / 3)
     * 
     * @param board 9×9的数独盘，'.'表示空格，'1'-'9'表示数字
     * @return 数独是否有效
     */
    public static boolean isValidSudoku(char[][] board) {
        // 布尔数组：记录数字使用情况
        // 索引0不使用，1-9对应数字1-9
        boolean[][] row = new boolean[9][10];     // 行中数字使用情况
        boolean[][] col = new boolean[9][10];     // 列中数字使用情况  
        boolean[][] bucket = new boolean[9][10];  // 3×3子网格中数字使用情况
        
        // 遍历整个9×9数独盘
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                // 计算当前位置所属的3×3子网格编号
                // 子网格按行优先编号：
                // 0 1 2
                // 3 4 5  
                // 6 7 8
                int bid = 3 * (i / 3) + (j / 3);
                
                // 跳过空格子
                if (board[i][j] == '.') {
                    continue;
                }
                
                // 将字符转换为数字
                int num = board[i][j] - '0';
                
                // 检查数字是否已在当前行、列或子网格中出现
                if (row[i][num] || col[j][num] || bucket[bid][num]) {
                    return false;  // 发现冲突，数独无效
                }
                
                // 标记数字在当前行、列、子网格中已使用
                row[i][num] = true;
                col[j][num] = true;
                bucket[bid][num] = true;
            }
        }
        
        return true;  // 遍历完成，未发现冲突，数独有效
    }
}
