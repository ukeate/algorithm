package leetc.top;

/**
 * LeetCode 11. 盛最多水的容器 (Container With Most Water)
 * 
 * 问题描述：
 * 给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。
 * 在坐标上画 n 条垂直线，垂直线 i 的两个端点分别为 (i, 0) 和 (i, ai) 。
 * 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
 * 
 * 说明：你不能倾斜容器。
 * 
 * 示例：
 * 输入：[1,8,6,2,5,4,8,3,7]
 * 输出：49
 * 解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。
 * 在此情况下，容器能够容纳水的最大值为 49。
 * 
 * 解法思路：
 * 双指针算法：
 * 1. 左指针指向数组开头，右指针指向数组末尾
 * 2. 计算当前容器面积：min(height[left], height[right]) * (right - left)
 * 3. 移动较短的那一边的指针：
 *    - 如果左边较短，左指针右移
 *    - 如果右边较短，右指针左移
 * 4. 重复直到两指针相遇
 * 
 * 核心思想：
 * - 容器的容量由较短的板子决定（木桶原理）
 * - 移动较短的指针可能找到更高的板子，增加容量
 * - 移动较长的指针只会减少宽度，不会增加容量
 * 
 * 正确性证明：
 * - 假设最优解是 (i, j)，其中 h[i] <= h[j]
 * - 我们的算法不会错过这个解，因为：
 *   1. 当左指针到达 i 时，右指针还在 j 或 j 的右边
 *   2. 只有当右指针移动到 j 时，我们才会计算 (i, j) 的面积
 *   3. 算法保证会考虑所有可能的最优解
 * 
 * 时间复杂度：O(n) - 每个元素最多被访问一次
 * 空间复杂度：O(1) - 只使用常数额外空间
 * 
 * LeetCode链接：https://leetcode.com/problems/container-with-most-water/
 */
public class P11_ContainerWithMostWater {
    
    /**
     * 计算盛最多水的容器容量
     * 
     * @param h 高度数组，h[i] 表示位置 i 处的高度
     * @return 最大容量
     */
    public static int maxArea(int[] h) {
        int max = 0;           // 记录最大容量
        int l = 0;             // 左指针，指向数组开头
        int r = h.length - 1;  // 右指针，指向数组末尾
        
        // 双指针向中间收缩
        while (l < r) {
            // 计算当前容器的容量
            // 容量 = 较短边的高度 × 宽度
            int currentArea = Math.min(h[l], h[r]) * (r - l);
            max = Math.max(max, currentArea);
            
            // 移动较短的边对应的指针
            // 这是贪心策略：移动较短边可能遇到更高的边，增加容量
            // 移动较长边只会减少宽度，不可能增加容量
            if (h[l] > h[r]) {
                r--;  // 右边较短，右指针左移
            } else {
                l++;  // 左边较短或相等，左指针右移
            }
        }
        
        return max;
    }
}
