package leetc.top;

/**
 * LeetCode 66. 加一 (Plus One)
 * 
 * 问题描述：
 * 给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。
 * 最高位数字存放在数组的首位，数组中每个元素只存储单个数字。
 * 你可以假设除了整数 0 之外，这个整数不会以零开头。
 * 
 * 示例：
 * - 输入：digits = [1,2,3]，输出：[1,2,4]（表示123 + 1 = 124）
 * - 输入：digits = [9]，输出：[1,0]（表示9 + 1 = 10）
 * - 输入：digits = [9,9]，输出：[1,0,0]（表示99 + 1 = 100）
 * 
 * 解法思路：
 * 模拟加法运算 - 从个位开始处理进位：
 * 1. 从数组末尾（个位）开始向前遍历
 * 2. 如果当前位小于9，直接加1并返回（无进位）
 * 3. 如果当前位等于9，置为0并继续处理下一位（有进位）
 * 4. 如果所有位都是9，需要创建新数组[1,0,0...0]
 * 
 * 关键观察：
 * - 只有遇到9才会产生进位，否则直接加1即可
 * - 如果整个数都是9（如999），结果是1000，长度+1
 * 
 * 时间复杂度：O(n) - 最坏情况下需要遍历整个数组
 * 空间复杂度：O(1) 或 O(n) - 通常是O(1)，只有全9时需要O(n)创建新数组
 */
public class P66_PlusOne {
    
    /**
     * 对数组表示的大整数加一
     * 
     * 算法步骤：
     * 1. 从右向左遍历数组（从个位到高位）
     * 2. 遇到非9数字：直接加1并返回原数组
     * 3. 遇到9：变为0，继续处理高位（模拟进位）
     * 4. 全是9的情况：创建长度+1的新数组，首位为1，其余为0
     * 
     * @param digits 表示非负整数的数组
     * @return 加一后的结果数组
     */
    public static int[] plusOne(int[] digits) {
        int n = digits.length;
        
        // 从个位开始处理（从右向左）
        for (int i = n - 1; i >= 0; i--) {
            if (digits[i] < 9) {
                // 当前位小于9，直接加1，无需进位
                digits[i]++;
                return digits;  // 立即返回，不需要处理更高位
            }
            
            // 当前位是9，加1后变为0，需要向高位进位
            digits[i] = 0;
        }
        
        // 执行到这里说明所有位都是9（如[9,9,9]）
        // 结果应该是[1,0,0,0]，长度比原数组多1
        int[] ans = new int[n + 1];
        ans[0] = 1;  // 最高位设为1
        // 其余位默认为0，Java数组初始化时自动为0
        
        return ans;
    }
}
