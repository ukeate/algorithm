package leetc.top;

/**
 * LeetCode 172. 阶乘后的零 (Factorial Trailing Zeroes)
 * 
 * 问题描述：
 * 给定一个整数 n ，返回 n! 结果中尾随零的数量。
 * 提示：n! = n × (n-1) × (n-2) × ... × 3 × 2 × 1
 * 
 * 进阶：你可以设计并实现对数时间复杂度的算法来解决此问题吗？
 * 
 * 示例：
 * 输入：n = 3   输出：0   解释：3! = 6，没有尾随0
 * 输入：n = 5   输出：1   解释：5! = 120，有1个尾随0
 * 输入：n = 25  输出：6   解释：25!的结果有6个尾随0
 * 
 * 解法思路：
 * 数学分析 - 质因数分解：
 * 1. 尾随零由10产生，而10 = 2 × 5
 * 2. 在阶乘中，2的因子数量总是比5的因子数量多
 * 3. 因此尾随零的个数 = 5的因子个数
 * 4. 问题转化为：计算1到n中包含多少个因子5
 * 
 * 因子5的来源：
 * - 5的倍数：5, 10, 15, 20, 25, 30, ...  贡献 ⌊n/5⌋ 个因子5
 * - 25的倍数：25, 50, 75, 100, 125, ... 额外贡献 ⌊n/25⌋ 个因子5
 * - 125的倍数：125, 250, 375, ...       额外贡献 ⌊n/125⌋ 个因子5
 * - 以此类推...
 * 
 * 计算公式：
 * 因子5的总数 = ⌊n/5⌋ + ⌊n/25⌋ + ⌊n/125⌋ + ⌊n/625⌋ + ...
 *             = ⌊n/5^1⌋ + ⌊n/5^2⌋ + ⌊n/5^3⌋ + ⌊n/5^4⌋ + ...
 * 
 * 数学证明：
 * - 每个5的倍数贡献至少1个因子5
 * - 每个25的倍数贡献至少2个因子5（额外1个）
 * - 每个125的倍数贡献至少3个因子5（额外1个）
 * - 因此需要累加所有5的幂次的贡献
 * 
 * 算法优化：
 * 直接计算 n/5 + n/25 + n/125 + ...
 * 等价于：n/5 + (n/5)/5 + ((n/5)/5)/5 + ...
 * 
 * 时间复杂度：O(log n) - 循环次数等于log_5(n)
 * 空间复杂度：O(1) - 只使用常数额外空间
 * 
 * LeetCode链接：https://leetcode.com/problems/factorial-trailing-zeroes/
 */
public class P172_FactorialTrailingZeroes {
    
    /**
     * 计算n!中尾随零的数量
     * 
     * @param n 正整数
     * @return 尾随零的个数
     */
    public static int trailingZeroes(int n) {
        int ans = 0;
        
        // 计算因子5的总数：⌊n/5⌋ + ⌊n/25⌋ + ⌊n/125⌋ + ...
        while (n != 0) {
            n /= 5;     // n除以5，得到当前5的幂次的贡献
            ans += n;   // 累加当前幂次的贡献
        }
        
        return ans;
    }
}
